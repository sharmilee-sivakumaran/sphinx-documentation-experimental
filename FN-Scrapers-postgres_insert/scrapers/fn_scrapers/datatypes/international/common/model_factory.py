# -*- coding: utf-8 -*-

import six
import os
import codecs
import inflection
import python_jsonschema_objects as pjo
try:
    import simplejson as json
except ImportError:
    import json

__all__ = ['ModelFactory']

def _generate_schema_namespace(schema_uri=None, schema_base_uri=None):
    basedir = schema_base_uri
    if schema_uri and isinstance(schema_uri, six.string_types):
        uri = os.path.normpath(schema_uri)

        if os.path.isfile(uri):
            basedir = os.path.dirname(uri)
        else:
            raise ValueError("Invalid JsonSchema file path. It should be a valid file path.")
    else:
        raise ValueError("JsonSchema file path and JsonSchema base dir path are required arguments(String type required).")

    if schema_base_uri and isinstance(schema_base_uri, six.string_types):
        if os.path.isfile(schema_base_uri):
            basedir = os.path.dirname(schema_base_uri)
        elif os.path.isdir(schema_base_uri):
            basedir = os.path.abspath(schema_base_uri)

    '''
    We are using https://github.com/abhiatoda/python-jsonschema-objects
    
    Here is https://github.com/abhiatoda/python-jsonschema-objects/blob/master/python_jsonschema_objects/classbuilder.py#L558
    
    this module generate a namespace which holds information about auto-generated classes for schema, sub-schema (here i mean which hold item type: object) and attributes of jsonschema.
    
    lets use schemas/doc_schema.json as our jsonschema:
    
    Assumption: Every block which "type" as "object", it must hold "title" field like "title": "canada_sponsor_schema" or "title": "canada sponsor schema". It will help us in picking up Schema class from namespace. In this example Sub-Schema class will be generated as "CanadaSponsorSchema".
    
    In model_factory.py:
    
    Lines:
    builder = pjo.ObjectBuilder(schema_uri, basedir)
    ns = builder.build_classes()
    
    Here we are creating namespace which hold all classes for Schema, sub-schema, and jsonschema properties, generated by this module.
  
    '''
    builder = pjo.ObjectBuilder(schema_uri, basedir)
    ns = builder.build_classes()
    return ns


def _generate_schema_classes_from_jsonschema(ns=None, schema_uri=None):
    '''
    This function is just to fetch class names for Schema definition and Properties/Attribute from namespace generated from
    builder = pjo.ObjectBuilder(schema_uri, basedir)
    ns = builder.build_classes()
    :param ns:
    :param schema_uri:
    :return:
    '''
    if not ns or not isinstance(ns, pjo.util.Namespace):
        raise ValueError("Value should be of Namespace type.")

    if schema_uri and isinstance(schema_uri, six.string_types):
        uri = os.path.normpath(schema_uri)
        if os.path.isfile(uri):
            with codecs.open(uri, 'r', 'utf-8') as fin:
                schema = json.loads(fin.read())
        else:
            raise ValueError("Invalid JsonSchema file path. It should be a valid file path.")
    else:
        raise ValueError("JsonSchema file path is required argument(String type required).")

    if 'title' not in schema:
        raise ValueError("title property must be present in JsonSchema.")
    nm = schema['title']
    nm = inflection.parameterize(six.text_type(nm), '_')
    nm = inflection.camelize(nm)

    billdoc_class = {nm: ns[nm] for key in ns.keys() if nm == key}

    if nm in billdoc_class:
        billdoc_class = billdoc_class[nm]
    else:
        raise AttributeError("{0} class not found in schema class namespace.".format(nm))
    schema_classes = {key: ns[key] for key in ns.keys() if 'schema' in key.lower() }
    attribute_classes = {key: ns[key] for key in ns.keys() if 'schema' not in key.lower()}

    return billdoc_class, schema_classes, attribute_classes


class ModelFactory(object):
    """
    Every Schema/Sub-schema definition must have "title" property.
    Here in this Canadian JsonSchema,

    first level of "title" is of Main Schema def:
        "title": "Canada doc schema",
        Auto-Generated class: "CanadaDocSchema"
        Object of Main schema class can be created by:
            bill_doc = self.model_factory.create_bill_doc()

    Second level of "title" is of sub schema sponsor:
        "title": "canada sponsor schema",
        Auto-Generated class: "CanadaSponsorSchema"

    JsonSchema for Canada:
    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "title": "Canada doc schema",
      "description": "Import schema for Canadian Bills",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "unique_bill_id",
        "title",
        "bill_number",
        "parliament",
        "session",
        "originating_chamber",
        "introduction_date",
        "type",
        "source_url"
      ],
      "properties": {
        "unique_bill_id": {
          "description": "REQUIRED, unique external identifier",
          "type": "string",
          "minLength": 1
        },
        "title": {
          "description": "REQUIRED, the title for the canada bill",
          "type": "string",
          "minLength": 1
        },
        "short_title": {
          "description": "the short title for the canada bill",
          "type": "string",
          "minLength": 1
        },
        "bill_number": {
          "description": "session-based bill identifier",
          "type": "string",
          "minLength": 1
        },
        "parliament": {
          "description": "REQUIRED, parliament identifier",
          "type": "integer"
        },
        "session": {
          "description": "legislative session",
          "type": "string",
          "minLength": 1
        },
        "originating_chamber": {
          "description": "chamber of origin of the bill",
          "type": "string",
          "enum": [
            "senate",
            "hoc"
          ]
        },
        "introduction_date": {
          "description": "date of introduction (date of the first action in the action list)",
          "type": "string",
          "format": "date"
        },
        "current_status": {
          "description": "last action text",
          "type": "string",
          "minLength": 1
        },
        "current_status_date": {
          "description": "date of last action",
          "type": "string",
          "format": "date"
        },
        "sponsors": {
          "description": "sponsors for the bill",
          "type": "array",
          "minItems": 1,
          "maxItems": 1,
          "items": {
            "title": "canada sponsor schema",
            "description": "description of critical sponsor information for Canadian legislation",
            "type": "object",
            "additionalProperties": false,
            "required": [
              "name"
            ],
            "properties": {
              "name": {
                "description": "REQUIRED, name of the sponsor",
                "type": "string",
                "minLength": 1
              },
              "title": {
                "description": "Tile or affiliation of the sponsor",
                "type": "string",
                "minLength": 1
              },
              "party": {
                "description": "Party of the sponsor",
                "type": "string",
                "minLength": 1
              }
            }
          }
        },
        "type": {
          "description": "type of bill",
          "type": "string",
          "enum": [
            "Senate Government Bill",
            "Senate Private Bill",
            "Senate Public Bill",
            "House Government Bill",
            "Private Memberâ€™s Bill"
          ]
        },
        "committees": {
          "description": "committees to which the bill was referred",
          "type": "array",
          "minItems": 1,
          "items": {
            "title": "committee schema",
            "description": "Schema for committee to which the bill was referred",
            "type": "object",
            "required": [
              "name",
              "chamber"
            ],
            "properties": {
              "name": {
                "description": "name of the committee",
                "type": "string",
                "minLength": 1
              },
              "chamber": {
                "description": "chamber of committee",
                "type": "string",
                "enum": [
                  "senate",
                  "hoc"
                ]
              }
            }
          }
        },
        "actions": {
          "description": "list of actions",
          "type": "array",
          "minItems": 1,
          "items": {
            "title": "action schema",
            "type": "object",
            "required": [
              "action_text",
              "action_date"
              ],
            "properties": {
              "action_text": {
                "description": "Action taken (for example: 'Introduction and First Reading')",
                "type": "string",
                "minLength": 1
              },
              "action_date": {
                "description": "Date of the associated action",
                "type": "string",
                "format": "date"
              },
              "chamber": {
                "description": "OPTIONAL, the chamber in which the action took place",
                "type": "string",
                "enum": [
                  "senate",
                  "hoc"
                ]
              }
            }
          }
        },
        "attachments": {
          "description": "OPTIONAL, the attachments for an international document",
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "./attachment.json"
          },
          "uniqueItems": true
        },
        "source_url": {
          " description": "URL from which the bill information was scraped",
          "type": "string",
          "format": "url"
        }
      }
    }

    attachment.json:

    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "title": "Attachment Schema",
      "description": "international attachment import",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "document_id",
        "download_id",
        "order",
        "process_status"
      ],
     "properties": {
        "document_id" : {
        "description":"REQUIRED, the document_id for the international document attachment from the document service",
          "type": "integer",
          "format": "int32"
        },
        "download_id": {
          "description": "REQUIRED, the download_id of the international document attachment from the document service",
          "type": "integer",
          "format": "int32"
        },
        "order": {
          "description": "lists the ordinal count of this document in the scrape, first lowest",
          "type": "integer",
          "format": "int32"
        },
        "process_status": {
          "description": "Procedural status associated with this document",
          "type": "string",
          "minLength": 1
        },
       "publication_date": {
         "description": "OPTIONAL, date status change occurred/document was made available, in UTC",
         "type": "string",
         "format": "date"
       },
        "locale": {
          "description": "ISO locale (language the document is in). Default value is English.",
          "type": "string"
        }
      }
    }


    """

    def __init__(self, schema_uri=None, schema_base_uri=None):
        if not schema_uri or not schema_base_uri:
            raise ValueError("JsonSchema File path and JsonSchema base dir path are required arguments.")

        self.ns = _generate_schema_namespace(schema_uri, schema_base_uri)
        self.bill_doc_class, self.schema_classes, self.attribute_classes = _generate_schema_classes_from_jsonschema(self.ns, schema_uri)

    def create(self, cls_name):
        if cls_name and cls_name in self.schema_classes:
            model = self.schema_classes[cls_name]()
            return model
        elif cls_name is None:
            raise ValueError("Class name is required argument.")
        else:
            raise AttributeError("Given class name is not found.")

    def create_bill_doc(self):
        try:
            bill_doc = self.bill_doc_class()
            return bill_doc
        except Exception as e:
            raise NameError("Bill Doc class can not be created. Error: {}".format(str(e)))

    def list_ref_schema_classes(self):
        '''
        this function will list all the classes generated for Schema or Sub-Schema of JsonSchema.
        :return:
        '''
        ref_schema = [x for x in self.schema_classes if x != self.bill_doc_class]
        return ref_schema

    def list_attribute_classes(self):
        '''
        this function will list all the classes generated for properties/attribute of JsonSchema.
        :return:
        '''
        return list(self.attribute_classes)

    def list_enum_values(self, attr_cls_name):
        '''
        this function will list all the enum values of any JsonSchema property.

        '''
        if attr_cls_name and attr_cls_name in self.attribute_classes.keys():
            attr_cls = self.attribute_classes[attr_cls_name]
            if hasattr(attr_cls, 'is_enum') and attr_cls.is_enum:
                return attr_cls.enum_values
        elif attr_cls_name is None:
            raise ValueError("Property class name is required argument.")
        else:
            raise AttributeError("Given property class name is not found.")

